<?xml version="1.0" encoding="utf-8" ?>
<XnaContent>
	<Asset Type="Osiris.Content.Pipeline.Graphics.Shaders.ShaderFragmentContent">
		<Name>Osiris.LightingModels.OrenNayar</Name>

		<Class>LightingModel</Class>

		<!-- Lists any constant registers used by the fragment -->
		<Parameters>
			<Item>
				<DataType>matrix</DataType>
				<Name>World</Name>
				<Semantic>WORLD</Semantic>
			</Item>
			<Item>
				<DataType>float3</DataType>
				<Name>CameraPosition</Name>
				<Semantic>CAMERAPOSITION</Semantic>
			</Item>
			<Item>
				<DataType>float4</DataType>
				<Name>AmbientLightDiffuseColour</Name>
			</Item>
		</Parameters>

		<!-- Declares what data needs to be output from the vertex shader and input to the pixel shader -->
		<Interpolators>
			<Item>
				<DataType>float3</DataType>
				<Name>WorldPosition</Name>
			</Item>
		</Interpolators>

		<Functions>
			<![CDATA[
float4 ProcessLight(Light light, float3 cameraPosition,
	float3 worldPosition, float3 worldNormal,
	float4 materialDiffuseColour, float4 materialSpecularColour,
	float materialSpecularIntensity, float materialSpecularPower,
	float materialRoughness)
{
	float3 directionToCamera = normalize(cameraPosition - worldPosition);

	// http://www.gamasutra.com/view/feature/2860/implementing_modular_hlsl_with_.php?print=1
	// and ShaderX2 Introduction and Tutorials
	float VdotN = dot(directionToCamera, worldNormal);
	float LdotN = dot(light.DirectionToLight, worldNormal);
	float irradiance = max(0.0f, LdotN);
	
	float cos_theta_i = LdotN;
	float theta_r = acos(VdotN);
	float theta_i = acos(cos_theta_i);
	float cos_phi_diff = max(0.0f, dot(normalize(directionToCamera - worldNormal * VdotN), normalize(light.DirectionToLight - worldNormal * LdotN)));
	float alpha = max(theta_i, theta_r);
	float beta = min(theta_i, theta_r);
	
	// A = 1 - 0.5 * R^2 / (R^2 + 0.33)
	// B = 0.45 * R^2 / (R^2 + 0.09)
	float roughness2 = materialRoughness * materialRoughness;
	float A = 1.0f - 0.5f * roughness2 / (roughness2 + 0.33f);
	float B = 0.45 * roughness2 / (roughness2 + 0.09f);
		
	float4 diffuse = materialDiffuseColour * (A + B * cos_phi_diff * sin(alpha) * tan(beta)) * irradiance;

	// Calculate Phong components per-pixel.
	float3 reflectionVector = normalize(reflect(-light.DirectionToLight, worldNormal));

	// Calculate specular component.
	// Specular light is light that gets reflected in a particular direction.
	// Because of this, specular light is view-dependent -- its intensity depends
	// on the angle between the light vector and the view vector. Specular lighting
	// is responsible for creating the highlights that make an object look shiny.
	float4 specular = saturate(light.DiffuseColour * materialSpecularColour * materialSpecularIntensity *
														 pow(saturate(dot(reflectionVector, directionToCamera)),
																 materialSpecularPower));
	
	return diffuse + specular;
}
]]>
		</Functions>

		<VertexProgram>
			<![CDATA[
VERTEX_OUTPUT main()
{
	float3 inputPosition;
	import(InputPosition, inputPosition = InputPosition);
	
	VERTEX_OUTPUT output;
	output.WorldPosition = mul(float4(inputPosition, 1), World);
	return output;
}
]]>
		</VertexProgram>

		<PixelProgram>
<![CDATA[
void main(PIXEL_INPUT input, inout PixelOutput output)
{
	// Import world normal - this will have either been exported by a simple pass-through
	// fragment which exported the normal coming from the vertex shader, or else it
	// might be a normal that was retrieved from a terrain normal map.
	float3 worldNormal;
	import(WorldNormal, worldNormal = WorldNormal);
	
	// Import material properties.
	float4 materialDiffuseColour, materialSpecularColour;
	float materialSpecularIntensity, materialSpecularPower, materialRoughness;
	import(MaterialDiffuseColour, materialDiffuseColour = MaterialDiffuseColour);
	import(MaterialSpecularColour, materialSpecularColour = MaterialSpecularColour);
	import(MaterialSpecularIntensity, materialSpecularIntensity = MaterialSpecularIntensity);
	import(MaterialSpecularPower, materialSpecularPower = MaterialSpecularPower);
	import(MaterialRoughness, materialRoughness = MaterialRoughness);
	
	// Calculate ambient colour.
	// Ambient light is a constant amount of light that gets added to the scene no matter what.
	// It's goal is to fake the contribution of indirect reflections, which can normally only be
	// accounted for using global illumination solutions. The ambient term is used simply to
	// keep shadows from turning pitch black, which would be very unrealistic.
	float4 ambient = AmbientLightDiffuseColour * materialDiffuseColour;
	
	// Now we import whatever lights have been exported by previous light fragments,
	// and process them one-by-one. Because light is additive, the final intensity of the light
	// reflected by a given surface is simply the sum of the ambient, diffuse and specular components.
	float4 finalColour = ambient;
	import(Light, finalColour += ProcessLight(Light, CameraPosition, input.WorldPosition, worldNormal, materialDiffuseColour, materialSpecularColour, materialSpecularIntensity, materialSpecularPower, materialRoughness));

	export(float4, LightColour, finalColour);
}
]]>
		</PixelProgram>
	</Asset>
</XnaContent>