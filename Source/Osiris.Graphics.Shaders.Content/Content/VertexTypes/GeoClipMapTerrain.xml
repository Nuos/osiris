<?xml version="1.0" encoding="utf-8" ?>
<XnaContent>
	<Asset Type="Osiris.Graphics.Shaders.ShaderFragment">
		<Name>GeoClipMapTerrain</Name>

		<Class>Vertex</Class>

		<!-- Lists any constant registers used by the fragment -->
		<Parameters>
			<!-- Vertex shader constants -->
			<Item>
				<DataType>float4</DataType>
				<Name>ScaleFactor</Name>
				<Description>
					ScaleFactor.xy: grid spacing of current level
					ScaleFactor.zw: origin of current block within world
				</Description>
			</Item>
			<Item>
				<DataType>float4</DataType>
				<Name>FineBlockOrig</Name>
				<Description>
					FineBlockOrig.xy: 1/(w, h) of texture
					FineBlockOrig.zw: origin of block in texture
				</Description>
			</Item>
			<Item>
				<DataType>float2</DataType>
				<Name>FineBlockOrig2</Name>
			</Item>
			<Item>
				<DataType>float2</DataType>
				<Name>ViewerPos</Name>
				<Description>
					Position of viewer in world coordinates
				</Description>
			</Item>
			<Item>
				<DataType>float2</DataType>
				<Name>AlphaOffset</Name>
				<Description>
					This is ((n - 1) / 2) - w - 1, where:
					  n = grid size
					  w = transition width
				</Description>
			</Item>
			<Item>
				<DataType>float2</DataType>
				<Name>OneOverWidth</Name>
				<Description>
					This needs to be the inverse of the transition width, which we choose
					as n / 10
				</Description>
			</Item>
			<Item>
				<DataType>float</DataType>
				<Name>GridSize</Name>
				<Description>
					Used when calculating the grid position of the vertex.
				</Description>
			</Item>
			<Item>
				<DataType>float</DataType>
				<Name>ElevationTextureSize</Name>
			</Item>
			<Item>
				<DataType>float4</DataType>
				<Name>ToroidalOffsets</Name>
				<Description>
					ToroidalOffsets.xy: toroidal origin in texture coordinates
					ToroidalOffsets.zw: size of grid inside texture, used for modulation
				</Description>
			</Item>
			
			<!-- Pixel shader constants -->
			<Item>
				<DataType>float</DataType>
				<Name>NormalMapTextureSize</Name>
			</Item>
		</Parameters>

		<Textures>
			<!-- Vertex textures -->
			<Item>
				<Name>ElevationTexture</Name>
				<MipFilter>NONE</MipFilter>
				<MinFilter>POINT</MinFilter>
				<MagFilter>POINT</MagFilter>
				<AddressU>WRAP</AddressU>
				<AddressV>WRAP</AddressV>
				<Description>
					2D texture that stores heights at this level's resolution.
					It is a floating pointing texture, with data packed into the float
				</Description>
			</Item>
			
			<!-- Pixel textures -->
			<Item>
				<Name>NormalMapTexture</Name>
				<MipFilter>NONE</MipFilter>
				<MinFilter>LINEAR</MinFilter>
				<MagFilter>LINEAR</MagFilter>
				<AddressU>WRAP</AddressU>
				<AddressV>WRAP</AddressV>
				<Description>
					2D texture that stores the normal data.
				</Description>
			</Item>
		</Textures>

		<!-- Describes the format of the vertex shader input data -->
		<VertexInputs>
			<Item>
				<DataType>half2</DataType>
				<Name>Position</Name>
			</Item>
		</VertexInputs>

		<Interpolators>
			<Item>
				<DataType>float</DataType>
				<Name>Alpha</Name>
			</Item>
		</Interpolators>

		<VertexProgram>
<![CDATA[
void main(inout VERTEX_OUTPUT output)
{
	// convert from grid xy to world xy coordinates
	float2 worldPos = (gInput.Position * ScaleFactor.xy) + ScaleFactor.zw;
	
	// compute coordinates for vertex texture
	float2 uv = (gInput.Position * FineBlockOrig.xy) + FineBlockOrig.zw;
	float2 offsetUv = uv + ToroidalOffsets.xy;
	
	float2 zf_zd = tex2Dlod(ElevationSampler, float4(offsetUv + (0.5f / ElevationTextureSize), 0, 1)).xy;
	float zf = zf_zd.x;
	float zd = zf_zd.y;
	
	// compute alpha (transition parameter) and blend elevation
	float2 pos = gInput.Position + (FineBlockOrig2.xy * GridSize);
	float2 alpha = clamp((abs(pos - ViewerPos) - AlphaOffset) * OneOverWidth, 0, 1);
	alpha.x = max(alpha.x, alpha.y);
	float z = zf + (alpha.x * zd);
	
	// export position
	float3 inputPosition = float3(worldPos.x, z, worldPos.y);
	export(float3, InputPosition, inputPosition);

	output.TexCoords = uv;
	output.Alpha = alpha.x;
}
]]>
		</VertexProgram>

		<PixelProgram>
<![CDATA[
void main(PIXEL_INPUT input, inout PixelOutput output)
{
	// do a texture lookup to get the normal in current level
	float4 normalfc = tex2D(NormalMapSampler, input.TexCoords + (0.5f / NormalMapTextureSize));

	// normalfc.xy contains normal at current (fine) level
	// normalfc.zw contains normal at coarser level
	// blend normals using alpha computed in vertex shader
	float3 normal = float3(lerp(normalfc.xy, normalfc.zw, input.Alpha.xx) * 2.0f - 1.0f, 1.0f);
	normal = normalize(normal.xzy);

	export(float3, WorldNormal, normal);
}
]]>
		</PixelProgram>
	</Asset>
</XnaContent>